function [] = get_gorillaAudioData(exptName, exptId, taskType, taskIds, ppIds, columns, displaySpec, responseSpec)
% Takes CSV of speech imitation data as generated by Gorilla and parses it for the necessary data:
%
% 1. Participant
% 2. Trial 
% 3. Sound file URL
% 4. Sound file name
%
% Stores in Matlab array with fields for each of those. This is preliminary; each participant will eventually get their own
% expt and data so that it can be parsed with lab tools. Also this is a huge amount of data for all participants to be
% together. 
% 
% Input arguments: 
% 1. exptName: e.g., 'timitate'. The folder you would look for in the 'experiments' folder on the server. 
% 2. exptId: the experiment tag from the experiment that was run. Structure is experimentNumber-vVersionNumber. E.g. 
% --- timitate Production pilot experiment number: 45280
% --- timitate Production pilot version number: 36 (the version that actually got the full 5 people)
% --- thus experimentId is 45280-v36
% 3. taskId: optional. A cell array of task IDs to look for, the 4-character identifier on nodes in Gorilla. There are
% usually multiple because of counterbalancing (each configuration gets a node id). e.g. {'ru2g' 'rl36' 'ot23' 'sb48'} are
% all the task IDs for lexical decision in the pilot version of timitate 
% --- If not provided, will assume {'ru2g' 'rl36' 'ot23' 'sb48'}. Maybe there should be a lookup table for this? 
% 
% Function will look for the folder in acoustic data called 'data_exp_(experimentId)'). All CSVs are also prefixed with this.
% Initiated RK 
% Major version change 4/2/2021 to incorporate new argument structure and include audioread data 
% 

dbstop if error
%% default args

if nargin < 1 || isempty(exptName), exptName = 'firstRate'; end
if nargin < 2 || isempty(exptId), exptId = 'pilot'; end
if nargin < 3 || isempty(taskType), taskType = 'visualSpeechRate'; end
if nargin < 4 || isempty(taskIds)
    functionName = ['get_taskIds_' exptName]; 
    taskIds = feval(functionName, exptId, taskType);  
end
if nargin < 6 || isempty(columns), columns = {}; end
if nargin < 7 || isempty(displaySpec), displaySpec = 'trials'; end
if nargin < 8 || isempty(responseSpec), responseSpec = 'https://'; end

% Add the data_exp tag
exptTag = ['data_exp_' exptId]; 

%% Load in CSVs

% Get path where data is
dataPath = get_exptLoadPath(exptName,exptTag); 

% Get the list of columns that you want to keep (for easier concatenating)
standardColumns = {'ParticipantPrivateID', 'ParticipantPublicID', 'ExperimentID', 'TreeNodeKey', 'ExperimentVersion', 'ScheduleID',...                    % Metainfo
    'Response', 'Display', 'Screen',...                                                                     % Information about responses to find useful rows
    'TrialNumber'};                                                                % Trial information
keepColumns = [standardColumns columns];


% Loop through and make structure of tables
fprintf('Reading in CSVs...\n')
goodTaskIds = taskIds; 
rmTaskIx = []; 
warning('off', 'MATLAB:table:ModifiedAndSavedVarnames');                % Turns off warnings for header formatting
warning('off', 'MATLAB:textio:io:UnableToGuessFormat'); 

% Turn of the warnings about headers. I don't care. 
warning('off', 'MATLAB:table:ModifiedAndSavedVarnames'); 
for t = 1:length(taskIds)
    taskId = taskIds{t};
    % Some information for the user because this takes a while
    fprintf('Loading data from task %s...\n', taskId);
    
    % Find all of the files in the folder that match the task ID (may be from different experiments, different
    % participants...)
    taskFiles = dir(fullfile(dataPath, ['*' taskId '*'])); 
    bKeepTask = length(taskFiles); 
    
    % Initiate empty taskInfo
    taskInfo = []; 
    for c = 1:length(taskFiles)   
        % Run through each CSV 
        csvFilename = taskFiles(c).name; 
        taskInfoNew = []; 
    
        try
            % Try to load. Catching errors: doesn't exist
            taskInfoNew = readtable(fullfile(dataPath, csvFilename)); 
            
            if isempty(taskInfoNew)
                bKeepTask = bKeepTask - 1; 
            end
        catch
            warning('Something went wrong: task %s\n', taskId); 
            bKeepTask = bKeepTask - 1; 
        end
        
        % Concatenate
        taskInfo = [taskInfo; taskInfoNew(:, keepColumns)];
        
    end
    if ~bKeepTask
        if ~ismember(t, rmTaskIx)
            rmTaskIx = [rmTaskIx t]; 
        end
    end
    csv.(['task_' taskId]) = taskInfo; 
    
end

goodTaskIds(rmTaskIx) = []; 
if isempty(goodTaskIds)
    warning('No CSVs found for this experiment. Stopping script.\n'); 
    return; 
end


%% Loop through csv structure to hit each table. This just gets the basic information---not the actual sound vector yet 
fprintf('Generating initial structure...\n')
for t = 1:length(goodTaskIds)
    taskId = goodTaskIds{t}; 
    dataTable = csv.(['task_' taskId]); 
    
    if any(size(dataTable) == 0)
        continue;  
        % Sometimes branches are empty, so the CSV will be empty even though it exists 
    end
    
    % Rows where we are in the correct display (we should uniformly make this "Trials" across all experiments) 
    trialRows = find(strcmp([dataTable.Display], displaySpec));
    
    % Find rows where there is a .weba URL. These are the trials where something has been recorded. 
    responseRows = find(contains([dataTable.Response], responseSpec));

    % Now take the intersection
    dataRows = intersect(trialRows, responseRows); 
    
    % Forming the struct
    gorillaParticipant = dataTable.ParticipantPrivateID(dataRows)'; 
    participant = dataTable.ParticipantPublicID(dataRows)'; 
    task = dataTable.TreeNodeKey(dataRows)'; 
    trial = dataTable.TrialNumber(dataRows)'; 
    responseURL = dataTable.Response(dataRows)'; 
    stimulusPlayed = dataTable.stimulus(dataRows)';     

    taskStructure = struct('gorsubj', num2cell(gorillaParticipant), 'subj', participant, 'trialNo', num2cell(trial), 'task', task, ...
        'stimulus', stimulusPlayed, 'responseURL', responseURL); 
    if t == 1
        data = taskStructure; 
    else
        data = [data taskStructure];
    end    
    
end

%% Add in file names and stimdur 
fprintf('Adding in filename data...')
soundfilePath = get_acoustLoadPath(exptName,exptTag,'uploads'); 
soundfileList = dir([soundfilePath filesep '*.weba']); 
soundfileNames = {soundfileList.name}; 

for i = 1:length(data)
    % And stimulus duration 
    [stimDurStart, stimDurEnd] = regexp(data(i).stimulus, '_[0-9]+ms'); 
    data(i).stimDur = str2double(data(i).stimulus(stimDurStart+1:stimDurEnd-2)); 
    
    % Now get the name of the sound file that was downloaded into the uploads folder 
    soundURL = data(i).responseURL; 
    
    % The soundfile name has three unique identifiers: participant ID, filename, and task (because they repeat in the two
    % tasks, you must actually use task information to get the single unique file)
    splitResult = strsplit(soundURL, 'filename='); 
    taskId = data(i).task; 
    fileId = splitResult{2}; 
    partId = num2str(data(i).gorsubj); 
    
    soundfileIx = find(contains(soundfileNames, fileId) & contains(soundfileNames,partId) & contains(soundfileNames, taskId)); 
    try
        data(i).fileName = soundfileNames{soundfileIx};  
    catch
        errorSubj = data(i).subj; 
        if ~strcmp(errorSubj, lastSubj)
            warning('Empty ix, ppId = %s. Multiple experiment attempts?', errorSubj)
        end
    end
    
    lastSubj = data(i).subj; 
end



%% Save
fprintf('Saving structure to %s...\n', dataPath)
save(fullfile(dataPath, [exptId '_imitate' upper(taskType(1)) taskType(2:end) '_aggregateData.mat']), 'data'); 

% and expt whenever we get that 
fprintf('Done.\n')

end


